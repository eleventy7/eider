/*
 *
 *  * Copyright 2019-2020 eleventy7
 *  *
 *  * Licensed under the Apache License, Version 2.0 (the "License");
 *  * you may not use this file except in compliance with the License.
 *  * You may obtain a copy of the License at
 *  *
 *  * https://www.apache.org/licenses/LICENSE-2.0
 *  *
 *  * Unless required by applicable law or agreed to in writing, software
 *  * distributed under the License is distributed on an "AS IS" BASIS,
 *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  * See the License for the specific language governing permissions and
 *  * limitations under the License.
 *
 */

package io.eider.processor;

import io.eider.annotation.EiderObject;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic;
import javax.tools.JavaFileObject;
import java.io.IOException;
import java.io.Writer;
import java.util.HashSet;
import java.util.Set;

@SupportedAnnotationTypes( {
    "io.eider.annotation.EiderObject"
})
@SupportedSourceVersion(SourceVersion.RELEASE_11)
public class EiderAnnotationProcessor extends AbstractProcessor
{
    private static final String NEW_LINE = "\n";
    private static final String FOUR = "    ";
    private static final String EIGHT = "        ";
    private int sequence = 0;

    @Override
    public synchronized void init(ProcessingEnvironment processingEnv)
    {
        super.init(processingEnv);
        writeNote(processingEnv, "Eider is ready");
    }

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv)
    {
        if (roundEnv.processingOver() || annotations.isEmpty())
        {
            return false;
        }

        for (Element el : roundEnv.getElementsAnnotatedWith(EiderObject.class))
        {
            boolean continueProcessing = false;
            if (el instanceof TypeElement)
            {
                continueProcessing = true;
            }

            if (!continueProcessing)
            {
                break;
            }

            TypeElement element = (TypeElement) el;
            processObject(processingEnv, element);
        }

        return true;
    }

    private void processObject(ProcessingEnvironment processingEnv, TypeElement typeElement)
    {
        final String objectType = typeElement.getSimpleName().toString();
        final String classNameInput = typeElement.getSimpleName().toString();
        final String classNameGen = classNameInput + "Eider";
        final String packageName = typeElement.getQualifiedName().toString();
        final String packageNameGen = packageName.replace(classNameInput, "gen");
        sequence += 1;
        writeNote(processingEnv, "Eider is processing " + packageName + " - item: " + sequence);

        StringBuilder toWrite = new StringBuilder();
        toWrite.append(buildFrontMatter(processingEnv, typeElement, classNameGen, packageNameGen,
            packageName, classNameInput));
        toWrite.append(buildRead(processingEnv, typeElement, classNameInput));
        toWrite.append(buildWrite(processingEnv, typeElement, classNameInput));
        toWrite.append(buildEiderId(processingEnv, typeElement, sequence));
        toWrite.append(buildEndMatter(processingEnv, typeElement));

        try
        { // write the file
            JavaFileObject source = processingEnv.getFiler()
                .createSourceFile(packageNameGen + "." + classNameGen);
            Writer writer = source.openWriter();
            writer.append(toWrite);
            writer.flush();
            writer.close();
        } catch (IOException e)
        {
            // Note: calling e.printStackTrace() will print IO errors
            // that occur from the file already existing after its first run, this is normal
        }
    }

    private StringBuilder buildEndMatter(ProcessingEnvironment processingEnv, TypeElement typeElement)
    {
        final StringBuilder footer = new StringBuilder();
        footer.append(NEW_LINE);
        footer.append("}");
        footer.append(NEW_LINE);
        return footer;
    }

    private StringBuilder buildFrontMatter(ProcessingEnvironment processingEnv, TypeElement typeElement,
                                           String classNameGen, String packageNameGen, String packageName,
                                           String className)
    {
        final StringBuilder header = new StringBuilder();
        header.append("/* GENERATED BY EIDER - DO NOT MODIFY */");
        header.append(NEW_LINE);
        header.append("package " + packageNameGen + ";");
        header.append(NEW_LINE);
        header.append("import io.eider.EiderSerializable;\n");
        header.append(NEW_LINE);
        header.append("import org.agrona.DirectBuffer;\n" + "import org.agrona.MutableDirectBuffer;\n");
        header.append(NEW_LINE);
        header.append("public class " + classNameGen + " implements EiderSerializable");
        header.append(NEW_LINE);
        header.append("{");
        header.append(NEW_LINE);
        return header;
    }

    private StringBuilder buildEiderId(ProcessingEnvironment processingEnv, TypeElement typeElement, long sequence)
    {
        final StringBuilder eiderId = new StringBuilder();
        eiderId.append(NEW_LINE);
        eiderId.append(FOUR + "/**");
        eiderId.append(NEW_LINE);
        eiderId.append(EIGHT + "Returns the generated (or supplied) Eider ID.");
        eiderId.append(NEW_LINE);
        eiderId.append(FOUR + "*/");
        eiderId.append(NEW_LINE);
        eiderId.append(FOUR + "@Override");
        eiderId.append(NEW_LINE);
        eiderId.append(FOUR + "public int eiderId()");
        eiderId.append(NEW_LINE);
        eiderId.append(FOUR + "{");
        eiderId.append(NEW_LINE);
        eiderId.append(EIGHT + "return " + sequence + ";");
        eiderId.append(NEW_LINE);
        eiderId.append(FOUR + "}");
        eiderId.append(NEW_LINE);
        return eiderId;
    }

    private StringBuilder buildRead(ProcessingEnvironment processingEnv, TypeElement typeElement, String originalClass)
    {
        final StringBuilder read = new StringBuilder();
        read.append(NEW_LINE);
        read.append(FOUR + "/**");
        read.append(NEW_LINE);
        read.append(EIGHT + "Reads from the supplied DirectBuffer.");
        read.append(NEW_LINE);
        read.append(FOUR + "*/");
        read.append(NEW_LINE);
        read.append(FOUR + "@Override");
        read.append(NEW_LINE);
        read.append(FOUR + "public void read(DirectBuffer buffer, int offset)");
        read.append(NEW_LINE);
        read.append(FOUR + "{");
        read.append(NEW_LINE);
        read.append(EIGHT + "System.out.print(\"Hello\");");
        read.append(NEW_LINE);
        read.append(FOUR + "}");
        read.append(NEW_LINE);
        return read;
    }

    private StringBuilder buildWrite(ProcessingEnvironment processingEnv, TypeElement typeElement, String originalClass)
    {
        final StringBuilder write = new StringBuilder();
        write.append(NEW_LINE);
        write.append(FOUR + "/**");
        write.append(NEW_LINE);
        write.append(EIGHT + "Writes (mutates) the supplied MutableDirectBuffer.");
        write.append(NEW_LINE);
        write.append(FOUR + "*/");
        write.append(NEW_LINE);
        write.append(FOUR + "@Override");
        write.append(NEW_LINE);
        write.append(FOUR + "public void write(MutableDirectBuffer buffer, int offset)");
        write.append(NEW_LINE);
        write.append(FOUR + "{");
        write.append(NEW_LINE);
        write.append(EIGHT + "System.out.print(\"Hello\");");
        write.append(NEW_LINE);
        write.append(FOUR + "}");
        write.append(NEW_LINE);
        return write;
    }

    @Override
    public Set<String> getSupportedOptions()
    {
        final Set<String> options = new HashSet<>();
        return options;
    }

    private void writeNote(ProcessingEnvironment pe, String note)
    {
        pe.getMessager().printMessage(Diagnostic.Kind.NOTE, note);
    }

}
